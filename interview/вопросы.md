## Что здесь происходит?
*материал будет дополняться. поправки и критика приветствуются*  

  В рамках образовательного проекта [Мамкин Data Scientist](https://t.me/mommyscience) был проведен опрос, на основании которого образовался [ресурс](http://interview-mds.ru/), содержащий распространенные вопросы из собеседований мира Data Science.  
  
  Список постоянно обновляется, пользователи голосуют за популярные вопросы, дают свои трактовки и ответы в комментариях.  
  
  Этот репозиторий представляет собой лонгрид, содержащий выборку из этих вопросов и мои аннотации, не претендующие на полное раскрытие темы, но призванные передать суть ответа простыми словами или натолкнуть на его более глубокое рассмотрение.  
  
![](images/mds_interview.jpg)  

## Вопросы для интервью по специальности Data Science

### В чем отличие градиентного бустинга над деревьями от случайного леса? Какие базовые параметры настраиваются?  

Оба алгоритма являются ансамблями, но реализуют разные подходы: бустинг и беггинг соотвествтенно.  

 **Ансамбль** - набор из моделей, решающих одну задачу, результаты работы которых компонуются так, чтобы повысить эффективность и точность, в сравнении с прогнозом одной модели.  
 
 **Бустинг** - подход, при котором модели обучаются последовательно.  
 Эта техника использует идею о том, что следующая модель будет учится на ошибках предыдущей. Они имеют неравную вероятность появления в последующих моделях, и чаще появятся те, что дают наибольшую ошибку. Обучающая выборка на каждой итерации определяется, исходя из ошибок классификации на предыдущих итерациях. Из-за того, что предсказатели обучаются на ошибках, совершенных предыдущими, требуется меньше времени для того, чтобы добраться до реального ответа. 
  Плюсы: быстрый и точный
  Минусы: переобучается и не параллелится
   ![](images/boosting.jpg)

 **Беггинг** - подход, при котором несколько базовых моделей обучаются параллельно на различных подвыборках, при чем выборка может быть не только срезом строк, но и содержать в себе лишь некотурую часть столбцов (признаков) выбранных случайно. Результаты обучения всех моделей усредняются.  
 Эффективность бэггинга достигается благодаря тому, что базовые алгоритмы, обученные по различным подвыборкам, получаются достаточно различными, и их ошибки взаимно компенсируются при голосовании, а также за счёт того, что объекты-выбросы могут не попадать в некоторые обучающие подвыборки. Случайный лес - беггинг, в основе которого лежат модели деревьев решений.
  Плюсы: довольно точен, устойчив к выбросам
  Минусы: очень большой размер моделей, которые получаются в результате
   ![](images/bagging.jpg)
  
  Безовые параметры зависят от типа решаемой задачи (классификация, регрессия) и выбранной базовой модели, в общем случае это количество таких моделей, их ключевые ппраметры (вроде глубины дерева для деревьев решений) и праметры, отвечающие за раелизацию самого подхода (например как разбивать выборки при беггинге).  
  
  Картинки взяты [отсюда](https://vas3k.ru/blog/machine_learning/), крутая статья, рекомендую к прочтению
  
  ### Как вычислить минимальный размер выборки для проведения A/B теста?
  
   Для того чтобы понять, какой объем выборки нам нужен, нам нужно зафиксировать некоторые вещи. Во-первых, минимальный размер эффекта, который мы хотим померить. То есть для нашей метрики, насколько большие отклонения от показателя, который мы предполагаем, сохранится по умолчанию, если наши изменения вообще никак не влияют на пользователей, какой размер вот этого отклонения мы хотим замечать в эксперименте. Эта штука называется «размер эффекта». Далее, следующий показатель, который надо зафиксировать, — это допустимые вероятности ошибок первого и второго рода.  
   
   В A/B-тестах, как правило, мы проверяем гипотезы о том, что никакие наши примененные изменения не повлияли на пользователей вообще никак, и проверяем ее против альтернативы, что как-то повлияли. 
   Ошибкой первого рода в этой ситуации будет отвержение неверной нулевой гипотезы, то есть принятие не влияющих на самом деле на пользователей изменений. Ошибка второго рода — это, наоборот, отклонение действительно хороших и влияющих на пользователей изменений. Вот мы должны, для того чтобы рассчитать необходимый объем выборки, зафиксировать допустимые вероятности ошибок первого и второго рода. В статистике, как правило, используется вероятность ошибки первого рода — 0,05, а вероятность ошибка второго рода — 0,2. В вашем конкретном эксперименте стоимости ошибок первого и второго рода могут быть какими-то существенно разными, поэтому часто может оказаться выгодно вручную выбрать эти пороги на вероятности ошибок первого и второго рода. 
   Наконец, когда вы зафиксировали размер эффекта и допустимой вероятности ошибок, вы можете поступить следующим образом: вы берете название метода, который вы планируете использовать для сравнения ваших контрольных групп и экспериментальных групп, например Z-критерий или T-критерий, и вы используете калькулятор мощности этого критерия. Вообще, для всех статистических критериев между собой связаны сложными взаимосвязями несколько величин: тип альтернативы, размер эффекта, размер выборки и допустимые вероятности ошибок первого и второго рода. Если вы какие-то из этих величин фиксируете, вы можете рассчитать оставшиеся. То есть если вы фиксируете конкретный критерий и фиксируете конкретный тип альтернативы, вероятности ошибок первого и второго рода и минимальный интересующий вас размер эффекта, вы можете вычислить объем выборки, который для этого нужен. Для того чтобы это сделать, нужно использовать калькулятор мощности. Вы просто гуглите его, и для каждого конкретного критерия вы легко найдете десятки различных реализаций, в том числе не требующих никакого знания программирования.
   
 ### Как объяснить бизнесу, что значат ошибки I и II рода?
 
 ![](images/univ.jpg)
 
__Ошибку первого рода__ часто называют *ложной тревогой*, *ложным срабатыванием* или *ложноположительным срабатыванием* — например, анализ крови показал наличие заболевания, хотя на самом деле человек здоров, или металлодетектор выдал сигнал тревоги, сработав на металлическую пряжку ремня. Слово «положительный» в данном случае не имеет отношения к желательности или нежелательности самого события.

__Ошибку второго рода__ иногда называют *пропуском события* или *ложноотрицательным срабатыванием* — человек болен, но анализ крови этого не показал, или у пассажира имеется холодное оружие, но рамка металлодетектора его не обнаружила (например, из-за того, что чувствительность рамки отрегулирована на обнаружение только очень массивных металлических предметов).
 
 
### Какой функционал оптимизируется в задаче линейной регрессии? Как записать это в векторной записи?

<details>
    <summary>Осторожно! Баян!</summary>
    <img src="images/extra.jpg" alt="">
</details>

Напомню, что __линейная регрессия__ - это метод восстановления зависимости между двумя переменными. Её оптимизация сводится к [максимизации прадоподобия](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%BC%D0%B0%D0%BA%D1%81%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%B0%D0%B2%D0%B4%D0%BE%D0%BF%D0%BE%D0%B4%D0%BE%D0%B1%D0%B8%D1%8F), что эквивалентно минимизации среднеквадратичной ошибки (MSE), которая широко используется в реальных задачах.  

![](images/vector_mse.JPG)


### Виды метрик машинного обучения?
(*я так понимаю речь идет о метриках качества*)    
![](images/score.jpg)  
За шпорами [сюда](https://stanford.edu/~shervine/teaching/cs-229/cheatsheet-supervised-learning) и [сюда](https://stanford.edu/~shervine/teaching/cs-229/cheatsheet-unsupervised-learning) 

  __Классификация:__
  * accuracy
  * precision 
  * recall
  * F-measure
  * AUC-ROC и AUC-PR
  * Logistic Loss (*Данная метрика нечасто выступает в бизнес-требованиях, но часто — в задачах на kaggle. [Крутая статья](https://dyakonov.org/2018/03/12/%d0%bb%d0%be%d0%b3%d0%b8%d1%81%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b0%d1%8f-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d1%8f-%d0%be%d1%88%d0%b8%d0%b1%d0%ba%d0%b8/#more-6139)* )  
  
  __Регрессия__  
  * MSE
  * R<sup><small>2</small></sup> ([Коэффициент детерминации](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%8D%D1%84%D1%84%D0%B8%D1%86%D0%B8%D0%B5%D0%BD%D1%82_%D0%B4%D0%B5%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D1%86%D0%B8%D0%B8))
  * MAE
  * Квантильная ошибка (*нормальных мануалов не нашел, в двух словах - сильнее штрафует за недопрогноз, чем за перепрогноз*)
  
  __Кластеризация__ (*почитать можно [тут](https://habr.com/ru/company/ods/blog/325654/)*)
  * Adjusted Rand Index (ARI)
  * Adjusted Mutual Information (AMI)
  * Homogenity
  * Completeness
  * V-measure
  * Silhouette

### Как объяснить бизнесу метрику машинного обучения?

![](images/try.jpg)

Больше графиков, красивая диграмма, три раза сказать *"business value"*, можно подключать мимику.

На этот вопрос нет истинно верного ответа, я хотел написать о использовании интерпретируемых моделей, где на язык бизнеса можно перенести веса признаков в сетях/линейных алгоритмах или feature importance моделей на базе деревьев решений. Или упомянуть о силе аллегорий.. но не уверен, что таким вещам тут место. Но раз уж есть мемасик, то вопрос определенно стоит включить.

### Mean/median/mode — что это?  
(*Рекомендую к прочтению книгу В. Савельева "Статистика и котики"*)  

__Mean__ - среднее значение, полученное путем деления суммы элементов на их количество.  
__Median__ - медиана это число в середине выборки чисел: половина данных находится ниже этого значения, а половина выше.  
__Mode__ - мода, соответствующая значению, которое встречается чаще всего.  

![](images/moda.JPG)


### Что такое интерквантили? 

Интерквартиль (IQR - одна из мер разброса или рассеяния данных. Он равен разности между верхним и нижним (первым и третьим) квартилями. Другими словами IQR -  это ширина интервала, содержащего средние 50% выборки. Таким образом, чем меньше IQR, тем меньше рассеяние. Положительной чертой этого показателя является его устойчивость (робастность), т.е. на него слабо влияют выбросы.

### Что такое boxplot?

__boxplot, ящик с усами, диаграмма размаха__ — график, использующийся в описательной статистике, компактно изображающий одномерное распределение вероятностей. (*прим. часто помогает визуально определить выбросы*)

Выглядит следующим образом:  
![](images/boxplot.png)

### Что такое скользящее среднее?  

__Скользящее среднее__ — общее название для семейства функций, значения которых в каждой точке определения равны среднему значению исходной функции за предыдущий период. Скользящие средние обычно используются с данными временных рядов для сглаживания краткосрочных колебаний и выделения основных тенденций или циклов.

__Простое скользящее среднее__ - арифметическое среднее за заданный период.  
Рассмотрим на примере количества коммитов в гитхаб. 5-ти дневное среднее скользящее на сегодня высчитывается путем прибавления пяти количеств коммитов за предыдущие дни (т.е. сегодняшнее плюс четыре прошлых) и разделением их на 5. Т.е. если статистика была такой: 9, 8, 8, 9, 10, то простое среднее скользящее будет равно (9+8+8+9+10)/5=8,8. Следовательно, если я сегодня сделал 10 коммитов, среднее скользящее числа коммитов в день будет равно 8,8.

__Экспоненциальное среднее скользящее__ - считает более поздние данные более важными, за счет чего более быстро реагирует на изменения.  Просчет значения экспоненциального среднего скользящего более сложный: вычисление значения 5-ти дневного экспоненциального среднего скользящего на сегодня производится по следующей формуле: EMA[k, n] = EMA[k-1, n]+(2/(n+1))·(P-EMA[k-1, n]), где

  * EMA[k, n] — экспоненциальное скользящее среднее периода n на момент k
  * P — текущая цена

(*прости, друг, тут вроде нельзя использовать Latex для формул. Когда-нибудь я перепишу их красиво, но это не точно)

На самом деле не обязательно помнить формулу наизусть, главное понимать смысл, который заключается в том, что, при просчете экспоненциального среднего скользящего, более ранние значения имеют меньшее значение, а более поздние — большее значение.  

__Взвешенное скользящее среднее__, как и экспоненциальное, тоже придает более поздним данным больше «веса», но оно делает это более выражено и проще. При просчете 5-ти дневного взвешенного скользящего среднего, мы придаем сегодняшнему количеству коммитов пятикратный вес, вчерашнему — четырехкратный, позавчерашнему — трехкратный и т.д., а потом делим сумму всех произведений на сумму добавленного веса. Т.е. (1·8+2·8+3·9+4·10+5·11)/(1+2+3+4+5) = 146/15 = 9,73.  
Формула расчета проста: каждое значение, входящее в просчет взвешенного скользящего среднего, необходимо умножить на его порядковый номер, а потом разделить всю эту сумму на сумму порядковых номеров.  

### Объяснить, что такое ROC/AUC  
![](images/roc_auc.jpg)

__ROC/AUC__ - это метрика, позволяющая оценить качество бинарной классификации,более информативная, нежели accuracy и показывающая, как часто мы ошибаемся и __как__ мы ошибаемся. Задача бинарной классификации подразумевает два возможных класса, 0 и 1.  

Например, мы хотим понять, будет ли в какой-то день дождь (класс 1) или нет (класс 0). И ошибиться мы можем двумя способами:
    * сказать что дождя не будет, а он пойдет (*False Negative/ложнонегативное предсказание*)
    * сказать что дождь пойдет, а его не будет (*False Positive/ложнопозитивное предсказание*)
Если мы сказали что дождь пошел и угадали - это True Positive/ верноположительное предсказание.

Roc-кривая - это график зависимости True Positive от False Positive, а roc_auc - площадь под этой кривой. (*между синеньким и зелененьким*)  

![](images/roc_auc2.png)

### Что такое F-score и зачем его используют?

*Посмотри предыдущий вопрос, про roc_auc, где описано что такое False Negative и False Positive.*

__F-score, F-мера__ - еще одна метрика оценки качества бинарной классификации, так же позволяющая определить как часто мы ошибаемся.

Почему это важно? Мы уже определили, что ошибки бывают двух видов: ложноположительные и ложноотрицательные. И в случае если один из этих типов ошибок нам более страшен - мы постараемся его не допускать, даже в ущерб ошибкам другого типа.

Например тебе нужно определить порок сердца у человека. Тут лучше лишний раз допустить False Positive, и предположить болезнь у здорового человека, нежели упустить больного и не заметить ее. Метрика, которую мы бы максимизировали в этом случае называется __recall__.

Если мы пытаемся как можно реже делать ложноположительные предсказания - (*например это слишком дорого, как если мы ищем где копать нефть*) - то мы максимизируем метрику __precision__.  

__F-мера__ же представляет собой гармоническое среднее между __precision__ и __recall__. Она стремится к нулю, если любой из этих параметров стремится к нулю. Эту метрику мы хотим видеть высокой если нам важен баланс.

### Что значит AUC <0.5? Что с ним делать?  

В случае бинарной классификации (когда у нас есть только два класса), AUC — эквивалентна вероятности, что классификатор присвоит большее значение классу 1, чем классу 0, а если AUC < 0.5, то можно просто перевернуть выдаваемые значения классификатором потому, что у тебя противоположная ситуация.